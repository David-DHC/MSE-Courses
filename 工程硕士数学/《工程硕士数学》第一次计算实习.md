# 《工程硕士数学》第一次计算实习

---

>   软硕232 丁浩宸 2023213911

---

## 第二章 2

### 理论分析

本题涉及的主要理论是条件数与病态矩阵。如课本第59页所述，“当A的条件数cond(A)是个大数时，b或A的扰动会引起解x大的误差”。本题中（1）的条件数就是个大数，（2）不是，而它们解出的x差异确实较大，这印证了课本上的内容。

### 算法描述

本题涉及的主要算法是列主元消去法。其主要流程为：

-   对方程Ax=b形成的增广矩阵$[A|b]$的每一列，选取该列对角线及以下绝对值最大的一个数，将该数所在的行通过行交换移动到对角线所在行
-   利用初等变换进行消元，使得该列对角线以下的所有数均为0
-   重复以上两种过程，直至增广矩阵$[A|b]$左侧为上三角阵
-   解方程$Ax=b$（可直接解，也可利用回代法从最后一行往回解）

### 计算程序

```matlab
a1 = [3.01, 6.03, 1.99; 1.27, 4.16, -1.23; 0.987, -4.81, 9.34];
a2 = [3.00, 6.03, 1.99; 1.27, 4.16, -1.23; 0.990, -4.81, 9.34];
b = [1; 1; 1];

A = a2 % a = a1

[m, n] = size(A);
c = n + 1;
A(:, c) = b;
x = zeros(length(b), 1);
T = zeros(1, c);

for i = 1:n-1
    a = abs(A(i, i));
    [u,v] = max(abs(A(i:m, i))); % 找到对角线以下绝对值最大的数作为主元
    v1 = v + i - 1;
    if v1 ~= i % 交换
        T = A(i, :);
        A(i, :) = A(v1, :);
        A(v1, :) = T;
    end

    for j = i+1:n % 消元
        A(j, :) = A(j, :) - (A(j, i) / A(i, i)) * A(i, :);
    end
end

% 回代法求解x
x(n) = A(n, c) / A(n, n);
for m = n  -1 : -1 : 1 
    x(m) = (A(m, c) - A(m, m+1:n) * x(m + 1:n)) / A(m, m);
end

disp('输出A');
disp(a1);
disp('输出A');
disp(A(:,1:n));
disp('输出b');
disp(b');
disp('输出detA');
disp(det(A(:,1:n)));
disp('输出解向量x');
disp(x);
disp('输出（2）中A的条件数');
disp(cond(a2, "inf"));
% disp('输出（1）中A的条件数');
% disp(cond(a1, "inf"));
```

### 结果分析

-   对于（1）：由于条件数较大，因此矩阵呈病态，其计算结果误差较大

    ![image-20231018192509681](C:\Users\15858\AppData\Roaming\Typora\typora-user-images\image-20231018192509681.png)

-   对于（2）：事实上（2）的条件数仍然较大，因此不能简单地认定（2）的计算结果就是更接近正确的。

    ![image-20231018193332488](C:\Users\15858\AppData\Roaming\Typora\typora-user-images\image-20231018193332488.png)



## 第二章 5

### 理论分析

本题主要研究Hilbert矩阵的病态性，利用了扰动方程组解的误差估计（敏感性分析）的相关知识。主要使用了不等式$\frac{||\delta x||}{||x||}\leq Cond(A)\frac{||\delta b||}{||b||}$作为估计的依据。

### 算法描述

本题使用Gauss顺序消去法，其与上题的列主元消去法的区别为减少了挑选列主元并交换行这一步骤。由于Hilbert矩阵病态性过大，Matlab的Cholesky分解函数`chol`无法作用在Hilbert矩阵上，因此放弃使用Cholesky分解法解方程。

### 计算程序

```matlab
for n = 2 : 16
    x = ones(1, n);
    x = x';
    b = hilb(n) * x;

    A = hilb(n);
    [m, n] = size(A);
    c = n + 1;
    A(:, c) = b;
    x0 = zeros(length(b), 1);
    T = zeros(1, c);
    
    for i = 1:n-1    
        for j = i+1:n % 消元
            A(j, :) = A(j, :) - (A(j, i) / A(i, i)) * A(i, :);
        end
    end
    
    % 回代法求解x
    x0(n) = A(n, c) / A(n, n);
    for m = n  -1 : -1 : 1 
        x0(m) = (A(m, c) - A(m, m+1:n) * x0(m + 1:n)) / A(m, m);
    end
    disp('当前n值：');
    disp(n);
    disp('当前条件数：');
    disp(cond(hilb(n), "inf"))
    disp('Hnx=bn解出的解x0：');
    x0 = x0';
    disp(x0);
    disp('剩余向量r：');
    r = b - hilb(x) * x0;
    r = r';
    disp(r)
    disp('误差向量deltax：');
    deltax = x0 - x;
    deltax = deltax';
    disp(deltax)
end

n = 2:1:100;
tt = 2:1:100;
for i = 2:100
    tt(i-1) = log10(cond(hilb(i), "inf"));
end
plot(n, tt, '+');

```

### 结果分析

1.   以n为横轴，`log10(cond(hilb(n), 'inf'))`为纵轴作图

     ![image-20231018203628717](C:\Users\15858\AppData\Roaming\Typora\typora-user-images\image-20231018203628717.png)

     由图可知，Hilbert矩阵的条件数先是随着n指数上升，而后在$x>16$稳定在$10^{18}$到$10^{23}$区间。

2.   计算n从2到16的计算结果，示例输出如下（n=10）：

     ![image-20231018205400562](C:\Users\15858\AppData\Roaming\Typora\typora-user-images\image-20231018205400562.png)

3.   有效数字位的变化：根据公式$\frac{||\delta x||}{||x||}\leq Cond(A)\frac{||\delta b||}{||b||}$知，由于$r$的数量级是$10^{-16}$次方，因此当$Cond(A)\geq 10^{17}$次方时，有效数字位将变为0；否则，有效数字位为二者次方数绝对值的差。观察到$Cond(A)\geq 10^{17}$对应的$n\geq13$，确实在此时$\Delta x$出现了绝对值大于1（即绝对误差等于100%）的情况。

     ![image-20231019123901771](C:\Users\15858\AppData\Roaming\Typora\typora-user-images\image-20231019123901771.png)